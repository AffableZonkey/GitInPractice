## Recommended Team Workflows
ifdef::env-github[:outfilesuffix: .adoc]

In this chapter you will learn the two most popular Git workflows and two of my personal workflows:

* How to use Git Flow to manage branching and merging in a project
* How to use GitHub Flow to manage branching and merging in a project
* How to use Mike Flow Single to manage branching, rebasing and merging in a single release project
* How to use Mike Flow Multiple to manage branching, rebasing and merging in a multiple release project

### GitHub Flow
GitHub Flow was actually predated by Git Flow (<<git-flow>>) but I'll talk through it first because it is simpler.

GitHub Flow is so named because it is the Git workflow that came out of the GitHub organization. It was first formally described in a blog post by Scott Chacon in 2011 at http://scottchacon.com/2011/08/31/github-flow.html.

GitHub Flow is made very simple because it essentially only involves two types of branches: feature branches and the `master` branch. All commits are made on feature branches and then merged to the `master` branch after review in a Pull Request. All commits to `master` are considered stable. Additionally, GitHub deploys all commits to the `master` branch to their production web servers.

You can read more about GitHub Flow on GitHub's guide at https://guides.github.com/introduction/flow/index.html.

Let's look at a diagram to help us understand GitHub Flow:

.GitHub Flow
[[github-flow-diagram]]
image::diagrams/14-GitHubFlow.png[]

Let's look at <<github-flow-diagram>> from top (the oldest commit) to the bottom (the newest commit):

1.  The initial commit to a repository is on the `master` branch and made with `git add` and `git commit`.
2.  A new feature is being developed so it is branched off the `master` branch with `git checkout -b`.
3.  Another feature is developed in parallel so it too is branched off the `master` branch with `git checkout -b`.
4.  Commits are made to both feature branches with `git commit`. They are pushed periodically with `git push`. Commits may be rewritten locally with `git rebase --interactive` or `git commit --amend` before being pushed but are never rewritten after being pushed so `git push --force` is never required.
5.  A feature branch is submitted for review in a pull request either through the GitHub web interface or with `gh pull-request`. If any changes are needed due to comments in the pull request they are committed. The pull request is automatically updated after new commits have been pushed to the remote branch. When the branch is ready it is merged to `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`.
6.  The remaining feature branch wants the changes from `master` so merges them with `git merge --no-ff`. This may be simply to make use of them in the branch or to resolve conflicts in the feature branch before they are merged into `master`.
7.  The remaining feature branch is submitted for review, merged and deleted.

#### Pros and Cons
GitHub Flow's beauty is in its simplicity. It is very easy to use with Git, GitHub's web interface and any Git graphical tools that support branching and merging. As everything ends up in the `master` branch there's little concern about commits getting lost. A branch is created, committed to, reviewed in a pull request, committed to again if necessary, merged and deleted. If a branch exists it is because it either hasn't been merged to `master` or someone forgot to delete it. You can find out which easily with a `git merge`; Git will refuse to merge the same commit more than once.

As a large web application GitHub doesn't have versioned releases which are released to customers. They deploy every commit to the `master` branch when it is made to the production servers. This approach is known as _continuous deployment_. This approach works well for web applications but doesn't work so well for e.g. desktop application software that needs to be released to users and have them restart their application to update it. In this case because hotfixes cannot be pushed instantly it's important to do more stabilization. Additionally, some pieces of software need to support multiple versions at once e.g. new stable versions of v1.0 and v2.0. GitHub Flow doesn't account for this case at all. These more advanced cases call for a more advanced workflow. Let's see how Git Flow can help.

### Git Flow
Git Flow predates GitHub Flow but I'm covering it afterwards as it is a lot more complicated.

Git Flow was probably the first formal Git branching and merging workflow to take off. In 2010 Vincent Driessen wrote a blog post describing a Git workflow he had been using for his software projects at http://nvie.com/posts/a-successful-git-branching-model/.

Git Flow involves five different types of branches:

* The `master` branch is used only for stable releases. Every commit to the `master` branch is tagged immediately. Commits are never made directly but are merged in from hotfix or release branches.
* The `develop` branch is a long-lived branch (i.e. it is never deleted). It is used for the bulk of daily development either through bugfix commits directly to it, feature, release or hotfix branch merges to it.
* Feature branches are branched off `develop` and are used for new feature development. When they are ready they are merged back into `develop`. They can be named anything.
* Release branches are used to stabilize a release. They are branched off `develop` and have bugfixes made to them and hotfixes merged into them. Bugfixes and hotfixes are merged back into the `develop` branch. They are named prefixed with `release-`.
* Hotfix branches are used for small fixes that need an immediate new release. They are merged into `master` (where they are immediately tagged) and into the current release branch if it exists or `develop` if it does not. They are named prefixed with `hotfix-`.

Let's look at a diagram to help us understand Git Flow:

.Git Flow
[[git-flow-diagram]]
image::diagrams/14-GitFlow.png[]

Let's look at <<git-flow-diagram>> from top (the oldest commit) to the bottom (the newest commit):

1.  The initial commit to a repository is on the `develop` branch and made with `git add` and `git commit`.
2.  A release branch for the v1.x release series is branched off the `develop` branch with `git checkout -b`.
3.  A new feature is being developed so it is branched off the `develop` branch with `git checkout -b`.
4.  Another feature is developed in parallel so it too is branched off the `develop` branch with `git checkout -b`.
5.  Commits are made to the release branches with `git commit` for changes or fixes specific to a release but not applicable to other application development. For example, this may be changing a version number displayed in the application.
6.  Commits are made to both feature branches with `git commit`. They may pushed periodically with `git push` but typically to the developer's own remote repository rather than the main repository. Commits may be rewritten locally with `git rebase --interactive` or `git commit --amend` before being pushed but are never rewritten after being pushed so `git push --force` is never required.
7.  Commits are made to the `develop` branch for changes that are not significant enough to be feature branches and not needed on the release branches. For example, small tweaks to behavior of the application that are not fixes may be committed directly to the `develop` branch.
8.  A release branch is ready and merged to `master` with `git merge --no-ff`. It is not deleted but kept around indefinitely in case any more stable releases are needed from it. It is immediately tagged `v1.0` with `git tag` and pushed with `git push` and `git push --tags`.
9.  A new hotfix is needed for both the `develop` branch and a release branch so a hotfix branch is branched off the `develop` branch with `git checkout -b`.
10.  A hotfix branch is ready and merged to both `develop` and `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is immediately tagged `v1.0` with `git tag` and pushed with `git push` and `git push --tags`.
11.  A feature branch is ready and merged to `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`. It is immediately tagged `v1.1` with `git tag` and pushed with `git push` and `git push --tags`.
12.  A new release branch for the v2.x release series is branched off the `develop` branch with `git checkout -b`.
13.  A release branch is ready and merged to `master` with `git merge --no-ff`. It is not deleted but kept around indefinitely in case any more stable releases are needed from it. It is immediately tagged `v2.0` with `git tag` and pushed with `git push` and `git push --tags`.
14.  A hotfix branch is ready and merged to both `develop` and `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is immediately tagged `v2.1` with `git tag` and pushed with `git push` and `git push --tags`.

Git Flow also has a set of Git extensions which allow working through this workflow with some commands. For example, to create a new feature branch you can run `git flow feature start new-feature-name`. You can download these extensions and read more about them at https://github.com/nvie/gitflow.

#### Pros and Cons
These different types of branches allow both flexibility and a formal release process. With the desktop application example we were talking about previously Git Flow allows a way of keeping track of released versions, features in development, urgent and non-urgent bug fixes through branch naming. Having a formal flow through which branches are merged means that a review process can ensure that things are reviewed multiple times before going into a release.

This formal process comes at a cost, however. As you can see from the above workflow and diagram it is quite complicated to get to grips with. This can work well for organizations where people can be trained and on-boarded but less well for short projects or open-source projects which seek to attract many new contributors. Also, if you are using continuous deployment the number of merges requires from feature branch to `master` branch can be be excessive.

### Mike Flow
I've used many different Git workflows over the years from Git Flow, GitHub Flow to the Homebrew's and CMake's workflows mentioned in <<13-MergingVsRebasing#homebrew-s-workflow>> and <<13-MergingVsRebasing#cmake-s-workflow>>. They all have their pros and cons but my preferred workflow is something I've named for this book _Mike Flow_.

As we've seen with GitHub Flow and Git Flow different release processes are optimized for continuously deployed web applications versus more slowly received desktop applications. For this reason _Mike Flow_ has two slighly different workflows: Mike Flow Single and Mike Flow Multiple.

The "Single" and "Multiple" in these cases refer to how many different versions of the software you need to support at once. Say you have made a `v1.5` release and a `v2.0` release. Will you make a `v1.6` release after `v2.0`? If not, you want Mike Flow Single and if so you want Mike Flow Multiple. If you're doing contiuous deployment that's OK too; Mike Flow Single can be used in this fashion too.

#### Mike Flow Single
Mike Flow Single is essentially GitHub Flow with two extra elements:

1.  Branches can (and should be) rebased, rewritten and squashed where appropriate (i.e. to make history cleaner but not if the branch is being used by multiple people).
2.  Stable releases can be tagged on the `master` branch.

.Mike Flow Single
[[mike-flow-single-diagram]]
image::diagrams/14-MikeFlowSingle.png[]

Let's look at <<mike-flow-single-diagram>> from top (the oldest commit) to the bottom (the newest commit):

1.  The initial commit to a repository is on the `master` branch and made with `git add` and `git commit`.
2.  A new feature is being developed so it is branched off the `master` branch with `git checkout -b`.
3.  Another feature is developed in parallel so it too is branched off the `master` branch with `git checkout -b`.
4.  Commits are made to both feature branches with `git commit`. They are pushed periodically with `git push`.
5.  A feature branch is submitted for review in a pull request either through the GitHub web interface or with `gh pull-request`. If any changes are needed due to comments in the pull request they are committed. The pull request is automatically updated after new commits have been pushed to the remote branch. When the branch is ready it is merged to `master` with `git merge` and deleted with `git branch --delete` and `git push --delete`.
6.  The remaining feature branch wants the changes from `master` and to rewrite commits so is rebased and squashed on top of `master` with `git rebase --interactive`. This may be simply to make use of work from `master` in the branch, to resolve conflicts in the feature branch before they are merged into `master` or to cleanup commits by rewriting them.
7.  The remaining feature branch is submitted for review, merged and deleted.

#### Mike Flow Multiple
Mike Flow Multiple is essentially Mike Flow Single with release branches:

* Release branches are branched off of `master` and can be committed to directly, cherry-picked or merged to from feature branches.
* Unlike feature branches release branches are never rewritten.
* Tags are created on feature branches rather than `master`.

Let's look at a diagram to help us understand Mike Flow Multiple:

.Mike Flow Multiple
[[mike-flow-multiple-diagram]]
image::diagrams/14-MikeFlowMultiple.png[]

Let's look at <<mike-flow-multiple-diagram>> from top (the oldest commit) to the bottom (the newest commit):

1.  The initial commit to a repository is on the `master` branch and made with `git add` and `git commit`.
2.  A new feature is being developed so it is branched off the `master` branch with `git checkout -b`.
3.  A release branch for the v1.x release series is branched off the `master` branch with `git checkout -b`.
4.  Commits are made to both feature branches with `git commit`. They are pushed periodically with `git push`.
5.  A feature branch is submitted for review in a pull request either through the GitHub web interface or with `gh pull-request`. If any changes are needed due to comments in the pull request they are committed. The pull request is automatically updated after new commits have been pushed to the remote branch. When the branch is ready it is merged to `master` with `git merge` and deleted with `git branch --delete` and `git push --delete`.
6.  Commits are made to the release branches with `git commit` for changes or fixes specific to a release but not applicable to other application development. For example, this may be changing a version number displayed in the application.
7.  Another feature or fix is developed so a new feature branch is branched off the `master` branch with `git checkout -b`.
8.  A feature branch is ready and merged to both `master` and the release branch for the v1.x release series with `git merge` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is tagged `v1.1` with `git tag` and pushed with `git push` and `git push --tags`. The release branch is not deleted but kept around indefinitely in case any more stable releases are needed from it.
9.  Another feature is developed so a new feature branch is branched off the `master` branch with `git checkout -b`.
10.  A new release branch for the v2.x release series is branched off the `master` branch with `git checkout -b`.
11.  A fix is needed for the v2.x release series a new feature branch is branched off the v2.x release branch with `git checkout -b`.
12.  The feature branch fix is ready and merged to the v2.x release series branch with `git merge` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is tagged `v2.1` with `git tag` and pushed with `git push` and `git push --tags`.
13.  The remaining feature branch wants the changes from `master` and to rewrite commits so is rebased and squashed on top of `master` with `git rebase --interactive`. This may be simply to make use of work from `master` in the branch, to resolve conflicts in the feature branch before they are merged into `master` or to cleanup commits by rewriting them.
14.  The remaining feature branch is submitted for review, merged and deleted.

#### Pros and Cons
The two variants of Mike Flow allow any developers not interacting with a release to behave as if they were using GitHub Flow. Those developers are more experienced with Git are empowered by being able to use more advanced history rewriting on remote branches. This allows them to keep their work shared and backed up but still make changes before it is merged. Tags and multiple release branches are optionally added because they are necessary with some forms of software development such as desktop applications where multiple versions need to be supported. Obviously I'm biased but I think it provides the best of both Git Flow and GitHub Flow; a stable release and review structure but without the complexity as strictly a mandated process.

The main disadvantage with Mike Flow is that it is not a know workflow outside of this book and people who have worked with me! That said, I have know many other projects to adopt a very similar process. The other disadvantage is that its flexibility in history rewriting and branching may make mistakes easier to happen.

It's worth reading through and trying to understand all the workflows above and in <<13-MergingVsRebasing#homebrew-s-workflow>> and <<13-MergingVsRebasing#cmake-s-workflow> before deciding on a workflow for your own team. Ask yourselves how many code reviews you need before releasing code to customers, whether your team has advanced or basic Git experience, whether you want to be more permissive or more prescriptive and just which one "feels" best. Ultimately any of the workflows discussed in this book will be better than no workflow at all. Remember that Git is a powerful tool and it should help you and your team be more productive and write better software. Good luck with it!

### Summary
In this chapter you hopefully learned:

* How to use GitHub Flow to use feature branches and `master` for continuous deployment
* How to use Git Flow to create a strict release, bugfix and feature development process
* How to use Mike Flow to have a simple workflow for non-release operations with the power of history rewriting
